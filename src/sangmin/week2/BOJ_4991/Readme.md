1. 코드 설명
bfs로 탐색하고 난뒤 dfs를 진행해주었다.
처음 값을 입력 받으면서 더러운곳과 청소기의 위치를 구조체에 저장해준다. 이때, 청소기와 더러운곳의 차이점은 크게 존재하지 않기 때문에 동일한 구조체 배열 내에서 다루기로 하였다 -> dirtys[0]

값을 다 입력 받고 난 뒤에는, bfs탐색을 하기 위해 queue를 준비해준다. queue에는 갈 수 있는 노드의 x,y값과 그곳의 value(level, 몇단계 거쳐서 갈 수 있는지) 3가지 종류가 포함된다.

개념은 bfs로 모든 노드에서 노드까지(dirtys들의 element들만) 최단거리를 구해준다

예를 들어 청소기, 쓰레기1, 쓰레기2, 쓰레기3이 존재한다면
청소기 -> 쓰레기1
청소기 -> 쓰레기2
청소기 -> 쓰레기3
쓰레기1 -> 쓰레기2
쓰레기1 -> 쓰레기3
쓰레기2 -> 쓰레기3
이 반대의 경우는 똑같기 때문에 따로 구해주지 않는다.
위의 경우를 dp배열에 넣어준다. 이 때, dp[a][b] 의 뜻은 dirtys[a]부터 dirtys[b]까지의 최단 거리이다.

bfs를 0부터 더러운곳 전부를 끝내면 dp값이 다 차게 된다.

이제 노드에서 노드까지의 최단거리를 모두 알고있으니, 여기서부터는 dfs를 통해 최단거리를 구한다.

이제 순서를 정렬할 차례이다.
순서는 더러운곳이 3군데라고 가정할 때,
0 -> 1 -> 2 -> 3
0 -> 1 -> 3 -> 2
0 -> 2 -> 1 -> 3
0 -> 2 -> 3 -> 1
0 -> 3 -> 1 -> 2
0 -> 3 -> 2 -> 1
3 * 2 * 1 = 6가지의 경우의 수가 나온다.

그렇다면 더러운곳이 n군데라면 n!이 된다. 이는 n^2보다 많은 수치지만 다행히 더러운곳의 max값이 10이기 때문에 시간 제한은 피할 수 있었다.

이는 0(청소기)에서부터 dfs를 시작해 모든 노드를 방문해준다.
그렇게 방문을 하면서 0 -> 1로가는 가장 최단거리는 dp 배열에 저장되어있고 (dp[0][1])
1 -> 2로가는 가장 최단거리 또한 dp 배열에 저장되어있다 (dp[1][2])
3 -> 2로가는 가장 최단거리는 (dp[3][2] == dp[2][3])이 되겠다.
모든 경우의 수가 전부 dp 배열에 저장되어 있기 때문에
dfs를 돌아주며 모든 경로를 탐색하고, 그 경로의 끝에서 나온 값 중 가장 작은값이 정답이 된다.

2. 느낀점
bfs의 사용에 있어서 버벅였다. 처음에는 갈 수 있는지 없는지를 판단하고 그 다음에 실행할려고 했는데 그렇게 되면 map 탐색을 갈때마다 전부 다 해주어야 해서 이 문제는 dp문제라고 생각했다. (제출자가 나였기 때문에 dp임을 알고 있었기도 하다)
bfs는 시간이 오래 걸리기 때문에 처음에는 시간 초과를 먼저 염려하였지만 map의 크기가 20 * 20이라서 bfs하는데 시간이 그렇게 오래 걸리지 않을것이라고 예상했다.
bfs를 통해 모든 노드를 dp에 넣는 것 까지는 순조롭게 진행하였지만 그 후 모든 경우의 수를 찾고 경로를 만들면서 더하는 부분이 dfs라고는 생각하지 못했던 것 같다.

처음에는 경로를 만들기 위해 노가다 (모든 경우의 수를 다 반복문을 통해 작업하기)를 생각하였으나 이미 앞에서 bfs로 시간을 소비한 마당에 이는 말도 안된다고 생각했다. 결국 인터넷의 도움을 받았다.
예전에 배운적이 있는지는 모르겠지만 dfs를 통해 모든 경우의 수를 다 탐색할 수 있었다.


다행히도 시간은 200ms로 짧게 나온 것 같지만 매우 아쉬웠다. 검색하지 않고 문제를 해결 할 수 있을거라고 생각했지만 마지막 부분에서 삐걱였다.
또한 bfs와 dfs는 이미 배운 내용임에도 불구하고 코드를 짜는데 있어 어려움을 느꼈다.
dfs와 bfs는 중요한 내용인만큼 다시 공부해야겠다.
