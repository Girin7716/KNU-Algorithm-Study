<meta name='type' content ='bfs'>
<meta name='BOJ' content='BOJ1600'>
<meta name='difficulty' content='gold5'>
<meta name='url' content='https://www.acmicpc.net/problem/1600'>
<meat name='date' cotent='2021-05-31'>

1. 코드 설명

<hr>

bfs를 통해 노드에 대해 가장 최단 경로를 찾는 문제이다.

특이 케이스가 있다면 원숭이는 k번 동안 말처럼 행동할수있다.

언제 말처럼 행동할지는 원숭이 마음대로(랜덤)이기 때문에

모든 경우에 대해 생각해줘야한다.

따라서 최소한의 거리로 도달할수있는것을 기록하는 visit 2차원 배열에 몇번 말처럼 행동했는지까지 기록하기 위해 3차원 배열로 만들어준다.

    visit[y][x][말처럼행동한횟수] = y,x 까지 말처럼행동한횟수로 이동한 최소한의 거리

bfs를 위해 생성하는 큐에는 현재 원숭이가 몇번 뛰었는지의 정보까지 같이 기록해준다.

```cpp
    queue < pair < pair < int, int > , int > > q; // y, x, curK
```

맨 처음을 큐에 넣어주고 갈수있는 상하좌우에 대해 bfs를 실시해준다.

그 다음이 중요하다.

큐에는 현재 원숭이가 몇번 뛰었는지 기록되어있기 때문에 k 값을 이용하여

갈수있는 8방향에 대해 기록해준다.

이를 큐가 빌때까지 해주고, 마지막 0 ~ k 까지 visit 배열을 비교하여 최소값을 출력해준다.

2. 느낀점

<hr>

시간초과에 계속 걸렸지만 결국 해냈다.....

bfs 문제는 큐를 구현하는게 가장 관건인것 같다.