1. 코드 설명

dfs를 통해 cycle을 찾는 코드이다.

멤버가 팀이 되는 경우는 cycle을 이루는 것 밖에 없기 때문에 이를 찾아야 한다.

이 멤버가 cycle에 속하는지 아닌지, 아직 판단되지 않았는지는 cycle 배열을 통해 진행한다.

처음 dfs를 시작하게 되면 아직 이 멤버가 cycle인지 판단되지 않은 상태로 계속 dfs를 진행 할 것이다. 이 때, dfs에서 방문하게 된 멤버는 visit을 1로 바꾸어 준다.

dfs를 하다보면 결국에는 visit이 1이되는 순간이 반드시 올 것이다. 왜냐하면 아래처럼 가장 worst case를 생각해 보았을 때도

1 2 3 4 5 6
2 3 4 5 6 6

반드시 cycle은 하나가 나오게 되어있다.

이렇게 visit이 1이 된다면 그 후 경우는 2가지로 나뉘어지게 된다.

1. visit한 멤버가 cycle인지 아닌지 판단되지 않은 경우
2. visit한 멤버가 cycle인지 아닌지 판단 된 경우

1번의 경우는 결국 마지막으로 방문한 (dfs의 return 조건인 visit이 1인) 멤버가 cycle의 끝이 된다는 뜻이 되기 때문에 dfs를 풀어가면서 마지막 멤버가 가르키고 있는 멤버(return value)가 될때까지 cycle이라는 뜻이다. cycle을 시작하는 멤버가 됬어도 dfs의 return은 끝나지 않을 수 있다.
예를들어 

1 2 3 4 5 6 7

3 4 3 7 3 4 6

여기서 2번 index는 dfs의 시작이지만
2 -> 4 -> 7 -> 6 -> 4
이렇게 cycle에 속하지 않게 된다.
이를 cycles를 통해 판단하고, cycles는 이 예시일 경우 index 6이 되어 0이 되어 2가 cycle에 포함되지 않음을 나타낸다.


2번의 경우는 결국 dfs해서 마지막 멤버까지 도달하였지만 이 멤버가 cycle일 경우 그 cycle에 속할 수 없기 때문에 dfs를 거쳐온 모든 멤버가 결국 cycle이 되지 않는다는 뜻이다. 그 반대로 마지막 멤버가 cycle이 아닌 경우에도 똑같이 dfs를 거친 모든 멤버가 cycle이 아니기 때문에 전부 cycle이 아니게 된다.

이렇게 dfs를 1부터 n까지 cycle인지 아닌지 판단 안 된 경우의 멤버만 실행하게 되면 결과값이 나오게 된다.


2. 느낀점

dfs를 통해 찾는다는 접근은 맞았으나 처음에는 cycle인지 아닌지 판단하는 조건의 사용에 미흡함이 있었다. 이는 스터디 멤버 이채현의 도움을 받아서 해결하였다. 마지막 return 조건에서 마지막 멤버가 판단이 되고 return 하는 과정에서 만약 마지막 멤버의 value값이 포함되어 있으면 그 뒤로는 전부 cycle이라고 판단했기 때문이다.

이는 return 을 -1로 해주는것으로 해결했다.

처음에 모든 멤버를 찾는다는 것에서 bfs를 생각했지만 이는 틀린 생각이었다. 결국 멤버를 지목하게 되는것은 체인 형식으로 가게 될 것이고 worst case를 생각했을때 한줄로 길게 늘려진 형태가 되기 때문이다

1 2 3 4 5 6

2 3 4 5 6 6

즉 한번 방문 한 멤버가 cycle인지 아닌지 판단하는게 중요했고 이를 cycle배열을 따로 두어 해결했다.
