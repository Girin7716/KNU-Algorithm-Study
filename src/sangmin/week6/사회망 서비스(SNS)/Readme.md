1. 코드 설명
<hr>
dfs 하여 leaf node를 찾아내고 dp를 이용하여 구하는 방식이다. 이 또한 달빛 늑대와 비슷했던 도로 포장과 마찬가지로 카카오 블라인드 테스트 문제와 상당히 비슷했다. 이 문제는 graph이기 때문에 cycle이 생길 수 있기 때문에 visit을 두었다.

dfs하여 leaf node를 찾고나면 leaf node의 dp[0]과 dp[1]을 지정해준다. dp[0]은 이 노드가 참가하지 않았을 때의 최소값이고 dp[1]은 이 노드가 참가했을때의 최소값이다.

leaf node는 당연히 dp[0] = 0, dp[1]이 될것이다. leaf node를 찾고나면 dfs가 풀리면서 leaf node의 부모 노드로 간다. 이 부모 노드 또한 두가지 선택지가 있다. dp[0]을 할 경우 아직 이 노드의 부모노드는 알지 못하기 때문에 일단 이 노드의 자식노드들이 무조건적으로 다 참여해야한다. 따라서 dp[0][부모노드] += dp[1][자식노드들]이 될 것이다. 반대로 dp[1][부모노드]는 자식노드들이 참가를 하던 안하던 상관이 없다. 그렇다면 dp[0][자식노드들]과 dp[1][자식노드들]을 비교하여 작은 값을 더해주게 된다.

이를 계속 반복하면 dp[1][1]과 dp[0][1] 중 작은값이 결과값으로 나오게 된다.

2. 느낀점
<hr>
이미 풀었던 문제라 어렵지 않았다.
