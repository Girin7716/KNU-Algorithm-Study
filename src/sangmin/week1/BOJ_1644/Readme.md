1. 코드 설명

num을 입력하면 그 num 까지의 모든 자연수를 check 배열로 소수인지 아닌지 판단한다.

이 판단에는 에라토스테네스의 체 알고리즘을 사용하였다.

그 후, front와 rear를 두어 누적합형식으로 sum이 num이 되면 count + 1을 해주었는데,

기본적으로 rear를 움직여 주면서 sum에다가 소수인 자연수를 전부 더해준다. 그렇게 더해주다가 sum == num이면 count + 1을, sum이 num을 넘어서면 front를 움직여 주면서 sum에다가 front를 sum의 값에 마이너스 해준다. 그렇게 마이너스 해주다가 sum == num이면 count + 1을, sum이 num보다 작아지면 다시 rear를 움직여주고 이를 rear가 num이 될때까지 반복해준다.

양 끝을 움직여가면서 누적합을 구하는것이라고 생각하면 편하겠다.

맨 앞은 마이너스를, 맨 끝은 플러스를 담당하는 식이다.

2. 느낀점

처음에는 모든 경우의 수를 찾는 방식이라 bfs를 생각했지만 num의 범위가 400만이나 되기 때문에 시간이 너무 오래걸릴것이라 판단하였다. 따라서 누적합을 생각했고, 여기서 누적합을 어디서부터 시작하냐도 문제였다.

결국 누적합을 맨 처음부터 차근차근 올라가기로 결정했고 누적합이 num을 넘어선다면 그만큼 앞에서 빼주면 된다는 생각으로 코드를 작성하였다. 중요한 것은 '연속'된 소수의 합이기 때문이다.

만약 아무 소수나 골라서 합을 만들라고 하면 이는 탐색으로 찾아야 하겠지만 연속된 이라는 조건이 붙음으로써 front와 rear를 두어 누적합을 구하면 된다고 생각했다.

그 다음 문제는 소수를 어떻게 구하냐였는데 이는 솔직히 인터넷의 도움을 빌렸다. 처음에는 num 까지의 모든 수를 하나하나 나누어 보면서 하는 방식을 생각했는데 그렇게 되면 시간 복잡도가 n^2가 되어 시작하기도 전에 시간이 많이 소모되기 때문에 다른 방식이 필요했다. 그렇게 해서 참조한게 에라토네스의 체 알고리즘이었다.

1644문제를 풀면서 정답률이 50%에 가깝기 때문에 쉬운 문제라고 생각했으나, 소수를 구하는것에 있어서 몰랐던 알고리즘 코드를 알게되어 아직 공부해야 할 길이 멀다고 생각했다.