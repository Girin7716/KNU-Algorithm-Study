1. 코드 설명

dfs를 통해 최대 값을 찾는 코드이다.

상,하,좌,우 순으로 dfs를 진행하였으며 그 줄의 원소를 더하는 방식은 큐를 사용하였다.

배열을 상 으로 움직이기로 결정했다면, n번까지 돌면서 n번째 줄의 원소를 전부 큐에다가 넣고 한줄 한줄씩 ary에 pop을 해주었다. 이 때 큐에 push할 경우 0은 제외하고 push 하였다. 0은 이동하는 방향에서 숫자의 가운데에 있을 경우 무시되기 때문이다.

pop을 할 때 중요한 점은 만약 같은 숫자가 큐 안에 2개씩 존재한다면 pop할 경우 그 숫자의 2배를 돌려주고 front를 + 2 해주어야 한다는 점이다. 또 front가 rear보다 많은데도 계속 pop을 요청 할 경우 이는 빈 칸을 의미하므로 0을 return 해주었다.

이렇게 5번(dfs 5번)을 해주게 되면 예를 들어 상상상상상을 했을때의 최대값이 나오게 되고 이 dfs가 끝나면 그 다음은 상상상상하 했을때의 최대값이 나오게 된다.

2. 느낀점

max의 값을 찾는 것이기 때문에 결국 마지막 까지 (5번째) 가서의 max값이 중요해서 dfs를 사용했다. dfs는 종점을 찾는데 매우 탁월하기 때문이다.

하지만 20*20칸이나 되는 배열을 dfs하면 속도가 매우 느리지 않을까 걱정 했지만 이는 착각이었다. 결국 dfs는 4 * 4 * 4 * 4 * 4 = 1024번 진행하게 될 것이고 충분히 가능한 수치라고 생각했다. 여기서 조금 더 생각해보자면 level 5(5번째)에서의 상,하의 max값은 같고 좌,우의 max값은 같은 것을 알 수 있다. 만약 level이 5보다 넘게 진행된다면 상,하와 좌,우의 구분이 중요 할 수있지만 level 5가 마지막이기 때문에 결국 dfs의 진행은 4 * 4 * 4 * 4 * 2가 될 것이다.

코드에 추가하고 싶었지만 이미 정답을 맞춘 상황이라 따로 추가하지는 않고 또 코드가 길어질 것을 염려해 Readme.md에 추가하게 되었다.

탐색에 있어 어떤 알고리즘을 사용하여 푸는지 결정하는 능력이 매우 중요한 것 같았다.
