1. 코드 설명
팬더가 숲을 움직이며 대나무를 먹는 문제이다.

팬더는 무작위 위치에서 시작하기 때문에 모든 위치에서 모든 경로를 다 찾아보고 그 중, 가장 많이 갈 수 있는 거리를 구해야한다. 이는 dfs + dp로 해결해준다. dfs로만 문제를 풀면 반드시 시간 초과에 걸리게 될 것이다.

먼저 dfs를 하게 되면, dfs해서 방문한 node의 map value를 1로 지정해준다. 이는 dp에 이용하기 위함이다.

그 후, dfs를 하게 되는데, dfs는 다음에 갈 숲의 대나무가 더 많을 경우만 이동 할 수 있다.
이렇게 dfs를 끝까지하면 그 dfs의 끝에 도달한 map의 value는 1이 되었을 것이다. 그 후, 갈 곳이 없다면 map의 value를 리턴하게 해준다.

이 map의 value를 리턴받은 그 전의 dfs는 리턴받은 value와 현재 dfs위치 map의 value와 더해준다.

그 후 이 작업을 반복해준다면 결국 맨 처음 시작했던 dfs의 시작부분은 그 부분에서 갈 수 있는 가장 먼 거리의 값을 가지고 있게 될 것이다.

1 -> 1 -> 1 -> 1(dfs의 끝 1 return) -> 2(1+1 return) -> 3(1+2 return) -> 4(1+4 return)
이 dfs로 갈 수 있는 가장 긴 길이는 4가 된다.

dfs를 계속 해주는데, 조건이 있다. dfs는 map의 value가 반드시 0일 경우(visit 하지 않은 경우에만) 해준다. 또한 dfs를 할 때, 추가적인 조건이 있다.

dfs를 진행시키던 중, 만약 그 다음 칸으로 갈 수 있는데 이미 방문한 노드이면 그 노드의 map value를 단순히 가져와서 현재 dfs칸과 더해주기만 하면 된다. 이는 이미 그 노드에 방문해서 dfs를 진행했고, map에는 그 노드에서 갈 수 있는 가장 긴 길이가 저장되어 있기 때문이다.

이를 계속 반복해주면 결국 가장 긴 길이의 Dfs값을 구할 수 있게 되고 그게 정답이 된다.

2. 느낀점
dfs와 dp를 혼합한 문제는 저번에도 풀었기 때문에 이번에는 제한 시간내에 풀 수 있었다.
하지만 마지막 리턴 부분이 잘 기억이 안나서 생각하는데 고생했다. 시간이 매우 단축되었고, 이미 풀었던 문제긴 하지만 복습도 중요하다는 것을 느꼈다.

또한 확실히 dp가 매우 빠르다는 것을 느꼈다.
원래는 dfs만 이용하고 dp를 사용하지 않으면 36%쯤에서 시간 제한이 걸려버리게 되었다.
