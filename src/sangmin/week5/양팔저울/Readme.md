1. 코드 설명
<hr>
dfs + dp를 이용한 문제이다.
추의 개수만큼 dfs해가며 나올 수 있는 무게들을 전부 구해준다.

구해야 하는 경우는 4가지 이다.

1. 추1 + 무게를 이용해서 추2를 맞춤 -> 무게 = 추2 - 추1(둘 중 작은 값으로)
2. 추1 + 추2를 이용해서 무게를 맞춤 -> 추2 + 추1 = 무게
3. 추1만 이용해서 무게를 맞춤 -> 추1 = 무게
4. 추2만 이용해서 무게를 맞춤 -> 추2 = 무게
먼저 추1, 추2를 입력하면 위의 4가지 경우를 모두 구한다.

그렇다면 1 ~ 4번의 값은 만약 추3이 들어오게 된다면 조합 할 수 있는 경우의 수가 된다.

1 -> 2의 경우를 설명하자면 추2(10) - 추1(6)로 무게1(4)이 나오게 된다. 무게1(4)와 추3(10)을 이용하면 무게2(14)가 나오게 된다. 무게 14는 결국 추1~3으로 조합해서 나올 수 있는 무게가 된다. 추2 + 추3 - 추1 = 14

3 -> 1의 경우를 설명하자면 추1(6)으로 무게1(6)이 나오게 된다. 무게1(6)과 추3(10)을 이용하면 무게2(4)가 나오게 된다.
무게 4는 결국 추3 - 추1을 통해 나올 수 있는 무게가 된다.

이를 추의 개수만큼 해주면 결국
4^(추의 개수)만큼 연산을 해주게 된다.
이는 시간 제한에 걸리게 된다.

하지만 가만히 생각해보면
3번을 해봤더니 무게가 5가 나오게됬다. 또 같은 index에서 4번을 해봤더니 무게가 5가 나오게 됬다.
결국 다음 index에 똑같은 추1의 값을 전달해주게 된다. 이를 다음 index에 대해 1~4번 연산을 해주게 되면 어짜피 똑같은 결과를 의미없이 계속 dfs해주게 되는 것 이다. 이를 weight[index][n1]으로 해결해준다. 만약 다음 인덱스의 n1값이 이미 방문했다면 dfs를 실행하지 않는다. 이를 계속 해주면 result 배열에 true or false의 값이 다 차게 되고 result배열의 index가 모든 추를 사용해서 나올 수 있게 되는 경우의 무게가 되는것 이다.


2. 느낀점
<hr>
1 ~ 4번의 경우를 차근차근생각해보면 어렵지 않은 문제였다.
