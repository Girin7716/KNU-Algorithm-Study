1. 코드 설명
<hr>
dp[n][1] -> n번 node가 참석했을때의 매출 손실액이다.(작을수록 좋다)
dp[n][0] -> n번 node가 참석하지 않았을때의 매출 손실액이다.(작을수록 좋다)
이 개념을 기억하고

DFS를 통해 leaf node를 찾고(자식이 없고 부모만 있는 노드) DFS를 풀어가면서 진행한다.

leaf node를 찾게 되면 이 leaf 노드는 결국 자식이 없기 때문에 각각 dp의 값을 구하기 쉬울 것 이다.

1. leaf node가 참석하게 되면 -> dp[n][1] = node의 값
2. leaf node가 참석하지 않을 경우 -> dp[n][0] = 0

이제 leaf node에서 dp 값을 모두 구해줬다면, 이제는 부모 노드의 dp값을 구해줄 차례이다.

leaf node를 제외한 부모노드는 자식이 되기도 하고 부모가 되기도 한다.
그렇다면 leaf node바로 위의 부모 노드는 팀장이 될 것이다.

팀장 노드의 dp를 구하는것은 크게 3가지 경우로 나뉜다.
1. 팀장 노드가 참석하는게 이득일 경우 -> 아래 노드는 신경쓰지 않는다.
2. 팀장 노드가 참석하는게 이득이지 않지만 아래 노드 중 하나라도 참석하는게 무조건 이득일 경우
3. 팀장 노드가 참석하는것도 이득이지 않고 아래 노드 모두 참석하지 않는게 이득일 경우이다.

1번일 경우 어렵지 않다.
dp[n][1]을 구하는 것이고, 이는 n번 node밑의 모든 자식들의 dp[child][1], dp[child][0]을 찾아보며 둘 중 작은 값을 전부 더한다. 이 더한 sum은 결국 밑의 노드들이 참석을 하던 안하던, 나올 수 있는 가장 작은 값이다. 팀장 노드가 참석하게 되면 밑의 자식들은 참석 하던안하던 나올 수 있는 가장 작은 값만 가져오면 된다.
이 sum에 n번 node의 값을 더해준다.

2번의 경우또한 어렵지 않다.
dp[n][0]을 구하는 것이고, 이는 n번 node밑의 모든 자식들 중, dp[child][1]과 dp[child][0]을 비교해보며 만약 dp[child][1]이 dp[child][0]보다 작을 경우 (참석하는게 이득 일 경우)가 하나라도 나오게 된다면 dp[n][0]은 sum의 값이 들어가게 된다. sum은 child가 참석 하건 안하건 나올 수 있는 가장 작은 값이지만, 2번의 경우 그 중에 dp[child][1]이 참석하는 경우가 무조건 하나 이상은 나오게 되기 때문에 참석 여부는 걱정하지 않아도 된다.

3번의 경우가 생각하기 가장 어렵다.
dp[n][0]을 구하는 것이지만, 결국 자식 node 중 한명을 강재로 보내야 한다. 하지만 자식 node또한 모두 dp[child][0]을 선택하게 되었을것이다. sum은 dp[child][0]의 합이된다. 이 중에서 강제로 한명을 보내기 위해선 가장 손해가 적은 쪽 -> 참석할때와 안할때의 차이가 가장 적은 쪽을 보내게 되야한다.
말로만 설명하면 좀 어려운데. sum에는 dp[child0][0] ~ dp[childn][0]의 값이 전부 다 더해져있고, dp[n][0]은 sum + dp[childx][1]이라고 생각 할수도 있으나, sum에서 dp[childx][0]을 빼줘야 한다. sum + dp[childx][1] - dp[childx][0]을 했더니 가장 작게 나와야 한다. 그렇다면 dp[childx][1]과 dp[childx][0]의 차이가 가장 적은것을 골라야 sum + dp[childx][1] - dp[childx][0]이 가장 작아질 수 있다.


이 3가지 경우를 생각해가며 dp[n][1]과 dp[n][0]을 구해가면서 dfs를 풀어간다면 결국 dp[1][1]과 dp[1][0]의 값이 나오게 되고 이 둘 중 작은 값이 문제의 답이 된다.

2. 느낀점
<hr>
다른 부분은 충분히 생각할만 했지만 3. 팀장 노드가 참석하는것도 이득이지 않고 아래 노드 모두 참석하지 않는게 이득일 경우이다. -> 이 부분이 가장 생각하기 어려웠다. 단순히 dp[child][1]의 값 중 큰것만 골랐기 때문에 몇몇 문제는 틀렸다. 그래서 인터넷의 도움을 빌렸다. 조금만 생각하면 통과 할 수 있는 문제였는데 많이 아쉬웠다. 
