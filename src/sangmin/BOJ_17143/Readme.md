1. 코드 설명
알고리즘 문제 중에서 복잡한 알고리즘을 쓰는 문제가 아니기 때문에,

상어를 구조체로 표현하고, MAP 배열을 만들어 해결했다.

상어 구조체에는 다음의 정보가 저장된다.
catch = 잡혔는지, 먹혔는지, 살아있는지
r = r값
c = c값
direction = 방향
size = 상어 크기
velocity = 속도

최대 10000마리의 상어를 구조체 배열을 만들어 관리해주기로 하였다.

코드의 순서는 크게 세가지로 흘러간다.
1. 낚시꾼이 움직이고 잡기
2. 상어가 움직임
3. 같은 공간에 있는 상어가 잡아먹힘

원래 이런 순서로 코드를 짰으나, 상어가 배열 어느 칸에 있는지 바로 알 수 없기 때문에
2번 순서에서 상어가 움직이고 동시에 먹어주기로 하였다.

3번 순서는 단순히 MAP을 초기화 해주기로 하였다.

1. 낚시꾼이 움직이고 잡기
이 코드는 간단하다. 낚시꾼은 1번부터 C까지 한칸씩 움직이며 낚시 바늘을 밑으로 내리고 수면에 가장 가까운 상어를 잡는다. 이는 상어 구조체 배열을 돌아주며 낚시꾼과 같은 C 라인에 있는 상어 중, 가장 작은 r 값을 가진 상어의 catch를 1로 바꿔주고 count에 더해준다.

2. 상어가 움직임
상어의 크기만큼 구조체 배열을 돌아가며 이미 catch되거나, 잡아먹힌 상어를 제외하고 움직여준다.
이때, 중요한것은 상어의 방향과 속도, 위치이다.
상어를 한칸씩 움직여주며 계산하면 시간이 너무 오래걸리기 때문에 계산한번에 해결할 수 있는 방법이 필요했다. 나는 단순히 상어를 바라보는 방향의 시작에서 출발 하기로 하였다. 

한 줄의 길이가 6
바라보는 방향이 왼쪽
상어의 위치는 5
상어의 속도 8

라는 경우가 존재한다면, 상어는 오른쪽에서 2번째 칸에서 출발하는것이고, 이를 6번째 배열에서 출발한다고 바꾸었을때, 공식은 C - 상어의 위치 + 1 = 2가 된다. 이 결과값에 상어의 속도 8을 더해준다면
상어는 오른쪽에서 시작하여 10칸을 이동하게 된다.
6 5 4 3 2 1 2 3 4 5

여기서 중요한건 상어가 몇칸을 이동했는지에 대해 C-1로 나눈값과 나머지이다. 상어는 만약 C에서 좌로 출발한다고 했을때, C-1단위로 방향이 바뀌게 된다. 그렇다면 10칸을 이동하고 5로 나누어 주게 되면 나머지는 2가 된다. 근데 여기서 내가 생각을 잘못 한 것인지 몫이 홀수일때 방향이 반대가 되는데 몫이 짝수이고 나머지가 0일때도 방향이 반대가 되었다. 그래서 이 예외를 따로 넣어주기로 하고, 원래 개념은 
결과값을 C-1로 나누어 몫과 나머지 값을 구하게 된다. 여기서 몫은 방향을 바꾼 횟수이고, 나머지는 방향을 바꾸고나서 그 방향으로 나아간 칸의 수 이다.

위의 경우에서

몫이 2이고 나머지가 1이게 된다면, 방향을 2번 바꾸었으니 방향을 그대로 진행하고 오른쪽에서 1칸을 이동했기 때문에 C가 된다.

몫이 1이고 나머지가 3이게 된다면, 방향을 1번 바꾸고 왼쪽에서 3칸만큼 이동했기 때문에 방향은 반대가 되고, 상어의 c는 3에 위치하게 된다.

몫이 2이고 나머지가 3이게 된다면, 방향은 그대로고 오른쪽에서 3칸을 이동했기 때문에 C-2가 된다.

이를 상,하,좌,우 모두 적용하여 상어의 위치와 방향을 계산해준다.

쉽게 설명하자면 상어의 출발점을 모두 각자 바라보는 방향의 시작점으로 보고 상어의 위치만큼 더해주고 속도를 더해주어 상어가 시작점으로 부터 몇칸을 갔는지 계산하고, 상어는 C-1 or R-1단위로 방향을 바꾸고 그 시작점의 끝으로 가니까, 나머지 값만큼 이동하게 된다.

이렇게 상어의 위치를 구하면
상어의 위치에 상어의 사이즈를 넣어주게 된다.

이 때 경우가 3가지로 나뉜다.
1. 넣어주려 했는데 map이 상어의 크키보다 클 경우 (이미 어떤 상어가 도달했고 그 상어가 더 큰경우)
이 경우에 넣으려고 했던 상어는 잡아먹히게 되므로 catch를 -1로 바꾸어준다.
2. 넣어주려 했는데 map이 0인경우 (어떤 상어가 도달하지 않은 경우)
이 경우, 그냥 상어의 크기를 넣어준다.
3. 넣어주려 했는데 map이 0이아니고  map이 상어의 크기보다 작을 경우(어떤 상어가 도달했었지만 그 상어가 더 작은 경우)
이 경우, 그 상어를 먹어주고 위치를 차지해야 하는데 상어 구조체를 현재 움직인 상어 전까지 돌아주며 그 상어의 r과 c가 map의 r과 c와 같은 상어를 찾고 이 상어를 먹혔다고 표시해준다.

종료하면 상어의 움직임과 상어의 먹힘이 종료된다


3. 같은 공간에 있는 상어가 잡아먹힘
이 순서는 단순히 map을 초기화 시켜주는것으로 해결해주었다.



2. 느낀점
처음에는 상어의 위치구하는것은 신경쓰지 않고 어떻게 하면 상어를 효과적으로 표현하고 움직이고, 잡아멱혔음을 표시할까를 생각해보았다.

전부 움직여주고 그 다음에 상어의 잡아먹힘을 판단할까도 하였지만 내가 만든 알고리즘 구조상 그렇게 하게 된다면 배열을 한번 더 돌아야 하기 때문에 비효율적이라고 생각했다.

그렇게 되면 남은 경우는 상어를 움직이고나서 판단해주는것인데, 이를 map으로 해결해주었다.
막상 지금 생각해보면 전부 움직여주고 상어의 잡아먹힘을 판단하는것도 괜찮다고 생각했는데 그렇게 되면 상어의 위치와 size를 따로 저장해주어야한다.

생각보다 오래 걸렸다.

가장 오래 걸린부분 2가지를 뽑자면
1. 상어의 표현방법과 map의 표현 방법, 상어가 움직이고 잡아먹힘의 판단 등 이미 움직이고 난 뒤 상태를 표현하는 부분
이 부분은 내가 짠 코드가 최선이라고는 생각하지 않지만 아무런 도움 없이 짰다는 것에 의의를 두기로 하였다. 하지만 다음부터는 조금 더 효율적이고 빠른 속도로 짜야겠다고 마음 먹었다.
2. 상어의 움직임
상어의 움직임은 처음에 많이 헷갈렸다. 상과 우, 좌와 하를 묶어서 생각했지만 그래도 오래걸렸다. 최대한 단순히 생각하는게 핵심이었는데 상어가 부딪히고 방향전환하는 부분의 조건생각이 오래걸렸다.

다음부터는 코드를 조금 더 빨리 짜고 내가 생각한 부분을 코드로 구현 할 수 있게 하는 능력을 기른다는 생각으로 공부하기로 하였다.
