1. 코드 설명
<hr>
단순 문자열을 다루는 문제였다.
원래대로라면 for문의 중첩이 많아질수록 실행속도가 어마어마하게 늘어나지만
다행히 order이나 course의 수가 각각 10, 20 이하라서 단순 for문의 여러 중첩이 가능하다고 생각했다.

코드가 상당히 긴데 하나하나 설명하자면 tokens는[i][j]는 j번째 order의 i개 조합의 문자열이다.

tokens[3][1]은 order 1번의 문자열 3개로 나올 수 있는 모든 조합이다.

toknes[1][i] 는 order i의 문자 하나하나를 뜻한다.

이를 sort해주고 그 뒤로부터는
size 2 ~ course의 가장 큰 size까지 그 전 size의 문자열을 들고와서 계속해서 붙여 나가준다.
dp방식과 유사하다.
이렇게 되면 모든 문자열을 size마다 전부 구할 수 있게 된다.

이제 이 문자열을 map에 넣어준다.
넣어줄때, 만약 이 문자열이 존재하지 않는다면 새로 넣어주고 value를 1로 둔다.
만약 문자열이 존재한다면 그 map의 value를 + 1 해준다.

이렇게 되면 각 문자열마다 주문 한 갯수를 알 수 있게 된다.

이제 map을 계속해서 돌아주면서 각 course의 size마다 가장 많이 주문한 order를 찾게 되고
이를 answer에 넣어준다.

2. 느낀점
<hr>
다행히 n의 개수가 매우매우매우 적기 때문에 단순하게 해결 할 수 있었다.
다만 시간이 오래 걸렸다.
