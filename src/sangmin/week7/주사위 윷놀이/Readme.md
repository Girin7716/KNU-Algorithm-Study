1. 코드 설명
<hr>
각 32개의 발판을 전부 value 배열, index 배열로 나누어 만약 방향전환하는 칸에서 시작하게 되면 그 경우에 맞추어 칸을 이동해주고 기본적으로 dfs를 사용한다.

dfs를 level별로 해가며 결국 level이 10이될때까지 계속해서 해주는데, 이때 주의해야할 점은 그전에 말이 전부 다 움직였다고 해서 return을 해주면 안된다.

1~4번 말을 순서대로 번갈아가며 움직이고, 현재 말이 이동 할 수 있는지 없는지를 visit으로 나타내어 dfs를 종료 하고 나면 다시 이전 상태로 원상 복구해준다.

2. 느낀점
<hr>
원래는 이차원 배열의 Map을 사용하여 해결하려 했지만 어째서인지 마지막 종료 조건이 계속해서 돌아가게 되어 답이 꼭 10정도의 차이가 났다. 어쩔 수 없이 인터넷 참조를 했다.

dfs의 깊이가 10밖에 되지 않기 때문에 많아봤자 4^10의 횟수를 dfs로 해야했고 이는 충분히 해결 할수있는 수치였다.
