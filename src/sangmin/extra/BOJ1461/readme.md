<meta name='type' content ='BinarySearch 및 구현'>
<meta name='BOJ' content='BOJ1461'>
<meta name='difficulty' content='gold5'>
<meta name='url' content='https://www.acmicpc.net/problem/1461'>
<meat name='date' cotent='2021-05-12'>

1. 코드 설명

<hr>

무작위로 입력되는 배열을 정렬한 후, BinarySearch를 통해 어디까지가 음수이고 어디서 부터 양수가 시작되는지 구해준다.

그 이유는 간단하다.

**결국 중요한건 책을 옮기는 사람은 왕복을 해야한다.**

왕복을 최소한으로 하기위해선 **가장 멀리있는 장소를 맨 마지막으로 방문**해야한다. 

어짜피 다시 돌아올일이 없기 때문이다.

또한, 한번에 가지고 갈수있는 책의 수가 중요하다.

한번에 많이 가지고 가야지 이득일것이다.

쉽게 생각해보면 최대한 갈수있는곳까지 한번에 많이 들고가서 돌아오면서 책을 정리한다는 생각으로 문제를 접근했다.

음수를 갔다가 양수부분을 가는 행위는 어짜피 **책을 다시 들고가는 행위**와 똑같기 때문에 양수와 음수를 나누어서 생각한다.

테스트 케이스로 나온 

    7 2
    -37 2 -6 -39 -29 11 -28

를 정렬하면

    -39 -37 -29 -28 -6 2 11

이 된다.

한번에 가지고갈수있는 책의 수가 2개이기 때문에

-39를 갈때 -37의 책을 가지고 간다.

그 다음 -29를 갈때 -28의 책을 가지고 간다.

-6을 갈때 2의 책을 들고가는 행위는 하면 안된다.

어짜피 0 -> -6 -> 0 -> 2의 방식이나 혹은 그 반대로 갈것이기 때문에

양수와 음수를 독립적으로 보는것이 맞다.

책의 양이 한정되있기 때문에 0을 들려 책을 보충해야하는데 아무 의미없이 0을 들리면 반드시 손해가 나게 된다.

-6을 갈때는 그냥 -6의 책 한권만 들고가면 된다.

그 다음 11을 갈때 2의 책을 들고가면 된다.

이를 묶어보면

    {-39, -38} {-29, -28} {-6} {2, 11}

이 된다.

결국 idx 0에서 부터 한번에 들고갈수있는 책의 개수만큼 올라오면서

음수부분일때는 집합 중 가장 작은값 x -1 x 2를,

양수일때는 집합 중 가장 큰값 x 2를 더해주면 된다.

그리고 현재는 모든 거리에 대해 왕복으로 했기 때문에 가장 먼 거리는 편도로 가면 된다.

따라서 마지막에 가장 큰 거리를 빼준다.

2. 느낀점

<hr>

binarySearch를 직접 구현하는 문제였다.

그 외에는 특별할게 없었다.