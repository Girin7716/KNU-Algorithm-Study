1. 코드 설명
<hr>

해당 문제는 원래 cpp로 해결하려 했지만 long long의 범위에도 한계가 있어서 cpp로 코드 작성 후 파이썬으로 해결하였다.

문제 자체는 간단하다.

1은 01로 바꿔주고

0은 10으로 바꿔준다.

순서대로 적어보자면

1 -> 01 -> 1001 -> 01101001 -> 1001011001101001 -> ... 

정도로 바뀐다.

여기서 어느 정도 규칙을 살펴보자면

    1. 무조건 2^n의 배수로 커진다. 한개의 수가 2개로 분열한다.
    2. 분열하고 난 다음의 수를 절반으로 나누었을때 오른쪽에 위치한 수를 보면 분열하기 전의 수와 동일하다.
    3. 분열하고 난 수의 나머지 절반은 뒤쪽 수를 뒤집었을때와 같다.
   
사실 문제를 푸는데 가장 중요한 규칙은 2번이다.

3번은 딱히 중요하다기보다는 내가 사용 용도를 모르는것일수도 있다.

이 문제는 단순 계산으로 접근하기는 어렵다.

결국 최종 수는 거의2^1000와 근접할텐데 이를 절반으로 나누어 앞의 0의 패턴을 세는것은 시간이 오래걸릴것이다.

따라서 절반으로 나누어 작성하다 보면 어느정도 규칙성이 보인다.

n이 홀수이거나 짝수일때마다 규칙이 다를것이다.

    1번째(1) : 0 + 0 = 0
    2번째(01) : 1 + 0 = 1
    3번째(1001) : 1-1 + 1 = 1
    4번째(01101001) : 2 + 1 = 3
    5번째(1001011001101001) : 3-1 + 3 = 5

    홀수번째일때 전단계의 결과-1 + 전단계의 결과,
    짝수번째일때 전단계의 결과+1 + 전단계의 결과가 된다.

 따라서 코드는

```cpp
    for(int i = 3; i <= N; i++){
        if(i % 2) // 홀수
            result += (result - 1);
        else // 짝
            result += (result + 1);
    }
```
```python
    for i in range(3,N+1):
        if(i%2) :
            result =result + (result-1)
        else :
            result= result + (result+1)
```
처럼 계속 결과를 더해가면 될것이다.

2. 느낀점
<hr>

dp 카테고리에 있어 dp처럼 접근하려 했으나 도저히 패턴을 나누고 또 00이 두개나 겹치는 상황을 처리하기 힘들어 다른 방법으로 접근해봤다.

결국 이 전 단계의 계산값을 활용한다는 점에서는 dp방식인것 같다.