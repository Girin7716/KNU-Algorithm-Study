1. 코드 설명
<hr>

dp문제 중 가장 쉬운 문제가 아닌가 싶다.

dp[i][j] 배열은 i까지 k개의 수를 통해 i를 만드는 경우의 수이다.

dp[i][j]를 잘 살펴보면

0 <= n <= i인 n에 대해

dp[i][j] = dp[n][j-1]일 것이다.

우리가 원하는 수는 i를 만드는것인데 만약 0 ~ i의 수가 이미 존재한다면 나머지 수 만큼 j-1개로 만드는 경우의 수를 더하면 될것이다.

쉽게 설명하자면

```
    dp[1][1] = 0 ~ 1까지 1개의 수를 통해 1을 만드는 경우의 수이다.

    이는 1 밖에 나오지 않을것이다.

    dp[2][2] = 0 ~ 2까지 2개의 수를 통해 2를 만드는 경우의 수이다.

    이는 (2 + 0) (1 + 1) (0 + 2) = 3가지가 될것이다.

    dp[3][2] = 0 ~ 3까지 2개의 수를 통해 3을 만드는 경우의 수이다.

    이는 (3 + 0) (2 + 1) (1 + 2) (0 + 2) = 4가지가 될것이다.

    어느정도 규칙성이 보이기 시작한다. 하지만 k가 3개일때는 약간 달라진다.

    dp[2][3] = 0 ~ 2까지 3개의 수를 통해 2를 만드는 경우의 수이다.

    (2 + ()) (1 + ()) (0 + ())

    일단 빈칸으로 비워두었다. 이는 저 빈칸에는 이전에 구했던 dp배열의 값이 들어가기 때문이다.

    2 + () 부분에서 ()부분에 올 수 있는 dp배열은 dp[0][2] 일것이다.

    2라는 숫자가 나왔기 때문에 요구하는 값 2는 만족하지만 나머지 숫자 2개가 부족하기때문에 더해서 0이되는 2개의 수의 경우의 수 = dp[2][0] = 1 가지의 경우의 수가 나온다.

    1 + () 부분에서 ()부분에 올 수 있는 dp배열은 dp[1][2] 일 것이다.

    1이 나왔기때문에 나머지 값 1을 채우고 숫자 2개를 만족시키는 경우의 수 = dp[1][2] 이기 때문이다.

    이를 활용하여

    dp[3][10]을 구하자면

    dp[0][9] + dp[1][9] + dp[2][9] + dp[3][9]일 것이다.
```

이를 통해 원하는 N,K까지 점점 증가시켜 준다.

2. 느낀점
<hr>

경우의 수를 하나하나 적어보면 규칙성이 쉽게 보이는 문제라 dp문제중에서도 쉬운 축에 속하는 문제이다.

dp에 대해서 많이 부족하기 때문에 기본적인 문제를 많이 풀어봐야겠다.