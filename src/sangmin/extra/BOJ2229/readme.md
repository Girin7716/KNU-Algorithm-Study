1. 코드 설명
<hr>

[합분해](https://www.acmicpc.net/problem/2225)와는 또 다른 느낌의 dp문제이다.

일단 dp[i] = i번째 idx까지 그룹으로 묶었을때 나올 수 있는 최대의 차이이다.

    10
    2 5 7 1 3 4 8 6 9 3

같은 경우가 있을때

    dp[1] = 0일것이다.

    dp[2]는 2가지 경우가 나온다. 
    2, 5와
    2 5의 그룹으로 나눌 수 있다.
    dp[2] = 3이 된다.

    그렇다면 dp[n-1]을 구했다 가정하고 dp[n]을 구할때 어떻게 구하면 될지 한번 생각해보자면

    dp[0] ~ dp[n-1]까지의 dp는 모두 구했을것이다. 이 dp의 뜻은 안의 그룹이 어떻게 되있던지 간에 가장 최대의 차이가 저장되있다.

    dp[n-1], n이는 n을 하나의 그룹으로 봤을때 2가지로 나눈것이다.

    왼쪽은 어떻게 그룹지어지던 상관없다. 이미 최적화된 값이 있기 때문이다.

    그렇다면 오른쪽을 봤을때 n은 하나의 그룹으로 볼 수 있다.

    조금 더 확장해서
    
    dp[n-2], n-1, n
    dp[n-3], n-2, n-1, n

    과 같은 경우를 살펴보자면

    dp[n-2], (n-1, n)

    dp[n-3], (n-2, n-1, n) 과 같이 그룹으로 묶을수 있을것이다.
    dp[n-3], (n-2, n-1), (n)과 같은 그룹은 구하지 않아도 된다.

    만약 
    dp[n-3], (n-2, n-1, n)
    dp[n-3], (n-2, n-1), (n)
    둘 중 dp[n-3], (n-2, n-1), (n)이 최적화 된 값이라면

    dp[n-1], (n)을 구하는것과 다르지 않기 때문이다.

    이를 계속해서 확장시켜 나가다 보면 결국

    dp[n]은
    dp[n-1], (n)
    dp[n-2], (n-1, n)
    dp[n-3], (n-2, n-1, n)
    dp[n-4], (n-3, n-2, n-1, n)
    ...
    dp[0], (1, 2, 3, 4, ... , n-1, n)
    중 가장 큰 값을 고르면 될 것이다.

2. 느낀점
<hr>
[합분해](https://www.acmicpc.net/problem/2225)보다 어려운 문제였다.

dp중 이런 문제에 많이 약한것 같아서 많이 풀어봐야겠다.